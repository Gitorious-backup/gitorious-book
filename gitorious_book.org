#+TITLE:     The Gitorious Book
#+EMAIL:     support@gitorious.org
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: H:3 num:nil toc:t @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

#+BEGIN_HTML
<p><strong>31st October 2012: This is the new, official Gitorious
 documentation and is a work in progress.</strong> New content will
 arrive here gradually. In the meantime, please seek out the <a
 href="http://gitorious.org/gitorious/pages/Home">project wiki</a> or
 the Gitorious <a
 href="http://groups.google.com/group/gitorious?hl=en">Google
 group</a> for documentation and troubleshooting.</p>
#+END_HTML

* TODO Introduction
** History
** Features & benefits
** FOSS licensing
** Current maintainers
** Funding
* TODO How Gitorious works
** Overview: services, processes, packages
** How the web frontend works
   Briefly describe Rails/web architecture
** How the git backend works
File structure, how we handle incoming ssh/git operations, the gitorious script
* TODO Installation
** Automated installation
** Manual installation
*** Overview - common steps

*** CentOS / RHEL
*** Debian / Ubuntu
* TODO Using the web frontend
** Registering your user
** Adding your ssh key
** Creating your first project and repo
** Using Gitorious as a git remote
** Collaborating with others: merge requests
* Upgrades
** Versioning

As of July 7th 2011, Gitorious adopted a standard versioning scheme,
and the initial version was 2.0.0. This version was chosen
arbitrarily, but we chose 2 over 1 to reflect the fact that Gitorious
has been through a few major changes since its inception, and we've
had been around for almost 4 years at that point.

Below you can read about the types of changes and what they demand
from someone upgrading Gitorious. The changes are listed in order of
most to least frequent. Releases are available as tags of the form
“vx.y.z” in the Gitorious mainline repository.

*** Risks of upgrading

We will do our best to keep releases stable. Every release will be run
in production on gitorious.org prior to being tagged.

*** Patch versions

Patch versions indicate changes with minor impact for installs. In
general, the rules for patch versions are:

- Should not require database migrations
- Should not require configuration changes or additions
- Should not require changes in CSS (e.g. by changing existing markup)

In general: If you have a local install, you should be able to safely
upgrade patch releases without changing anything, even if you have
local CSS adjustments.

Because of these restrictions, patch upgrades should be considered
fairly trivial and of minimal risk. Refer to Upgrading for information
on checking your current version and upgrading.

*** Minor versions

Minor versions are bigger changes or changes that require action on
your part other than simply pulling from Git and restarting your
app. These changes may include:

- Database migrations
- Required configuration changes and/or additions
- Substantial changes/additions to the view
- API changes in models and key lib classes

Each minor version will receive its own entry in the documentation
chapter you're currently reading.

*** Major versions

Major versions will presumably occur infrequently, and there is no
specific rules to trigger an upgrade. Our rule of thumb right now is
that if a new version of Gitorious requires an entirely new
installation guide of its own, it’s probably a major release. However,
we may also up the major version number due to the addition of
substantial new features, redesigns and whatnot.

*** How often/when will Gitorious update its version?

Releases will be made on an irregular schedule, and will coincide with
gitorious.org deployments, but not in a 1:1 ratio. Occasionally we
deploy Gitorious a number of times throughout a single week, but do
not expect more than one version per week. Follow this page, or better
– the mailing list for updates.

** Approach 1: Manual upgrade

If your version of Gitorious is really old, please start with this
guide: [[https://gitorious.org/gitorious/pages/LegacyUpgrade][LegacyUpgrade]] ("really old" = older than February 3rd
2009/92bb70a1).

If your version Gitorious is only a little old, refer to [[https://gitorious.org/gitorious/pages/BundlerSetup][BundlerSetup]]
("a little old" = older than January 24th 2011/c44237f).

**** The changelog tool

As of Gitorious 2.0.0, Gitorious ships with a simple changelog
tool. The tool consists of a single rake task that can tell you what
version you are currently on and what versions are available to
you. To use it, invoke the following command from the root of your
installation:

=bundle exec rake changelog=

The tool will give you a list of available version along with an arrow
indicating your current version. If the arrow points to a green
number, you're on top of things. If it points to a red number, it
means that upgrades are available, and you are encouraged to stay up
to date.

To display a changelog for changes between your current version and
another version, run the tool with the `VERSION` environment variable
set:

#+begin_src shell
bundle exec rake changelog VERSION=2.0.1
#+end_src

**** Before upgrading

No matter how simple an upgrade may look, we strongly encourage you to
always back up your database and repository data prior to upgrades. If
nothing else, an upgrade is a good time to get some snapshots if you
don't already have scheduled backups of your system. It's also a good
idea to keep a copy of Gitorious configuration files outside the
actual install.

**** Upgrading patch versions

Patch upgrades should be trivial in nature. The steps are simple:

#+begin_src shell
cd /path/to/gitorious
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.x.y
rake assets:clear
#+end_src

Note that `rake assets:clear` was not available prior to 2.1.0. 2.0.x
can be directly upgraded to 2.1.0, see below.

As of 2.1.0 you also need these steps for any upgrade:

#+begin_src shell
git submodule init
git submodule update
rake db:migrate
#+end_src

Finally, restart all services. This includes the webserver, the poller
and the git daemon. x/y depends on the actual version.

**** Upgrading customized installs

If your Gitorious setup has changes, you may experience conflicts when
pulling in changes. It is recommended to push your patched version of
Gitorious somewhere, for example to itself, so you can easily clone
Gitorious to a local machine, or somewhere else on the server to make
sure that the patch will apply cleanly before attempting the upgrade.

**** Sample upgrade

Assuming you are on v2.0.0 or newer:

#+begin_src shell
bundle exec rake changelog
Available versions
v2.0.1              Next increment
-> v2.0.0           First versioned version of Gitorious
#+end_src

Obviously, there's a new version in town, so let's see what it offers:

#+begin_src shell
bundle exec rake changelog VERSION=2.0.1
Changes between v2.0.0 and v2.0.1:
A longer description appears here
#+end_src

This looks good, so let's upgrade:

#+begin_src shell
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.0.0
rm public/stylesheets/all.css public/javascripts/all.js public/javascripts/capillary.js public/**/*/gts-*.*
touch tmp/restart.txt
#+end_src

**** Upgrading from 2.0.x to 2.1

You can upgrade directly from any 2.0.x version directly to 2.1.0. Start by reviewing changes:

#+begin_src shell
bundle exec rake changelog VERSION=2.1.0
#+end_src

If this looks good, back up everything (see above), and get started:

#+begin_src shell
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.1.0
rake assets:clear
#+end_src

Gitorious now has submodules. Initialize and pull them, then upgrade
the database.

#+begin_src shell
git submodule init
git submodule update
rake db:migrate
#+end_src

Then restart your server (assuming you're using Passenger):

#+begin_src shell
touch tmp/restart.txt
#+end_src

**** Upgrading from 2.1.x to 2.2

You can upgrade directly from any 2.1.x version directly to 2.2.0. Start by reviewing changes:

#+begin_src shell
bundle exec rake changelog VERSION=2.2.0
#+end_src

If this looks good, back up everything (see above), and get started:

#+begin_src shell
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.2.0
rake assets:clear
git submodule --init update
#+end_src

Upgrade the database:

#+begin_src shell
rake db:migrate
#+end_src

Then restart your server (assuming you're using Passenger):

#+begin_src shell
touch tmp/restart.txt
#+end_src

If you want to use the new [[private repositories
 feature][https://gitorious.org/gitorious/pages/PrivateRepositories]], set the
=enable_private_repositories= setting to `true` in
config/gitorious.yml. See the sample configuration in
config/gitorious.sample.yml for more information.

**** Upgrading from 2.2.x to 2.3

You can upgrade directly from any 2.2.x version directly to 2.3.0. Start by reviewing changes:

#+begin_src shell
bundle exec rake changelog VERSION=2.3.0
#+end_src

If this looks good, back up everything (see above), and get started:

#+begin_src shell
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.3.0
rake assets:clear
#+end_src

Gitorious now has submodules. Initialize and pull them:

#+begin_src shell
git submodule init
git submodule update
#+end_src

Upgrade the database:

#+begin_src shell
rake db:migrate
#+end_src

Then restart your server (assuming you're using Passenger):

#+begin_src shell
touch tmp/restart.txt
#+end_src

**** Upgrading from 2.3.0 to 2.3.1

To upgrade from version 2.3.0 to 2.3.1, follow these steps:

#+begin_src shell
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.3.1
bundle install
rake assets:clear
touch tmp/restart.txt
#+end_src
**** Upgrading from 2.3.1 to 2.3.2

To upgrade from version 2.3.1 to 2.3.2, follow these steps:

#+begin_src shell
git fetch git://gitorious.org/gitorious/mainline.git
git merge v2.3.2
bundle install
rake assets:clear
touch tmp/restart.txt
#+end_src

** Approach 2: Snapshot old instance, restore state in a newly installed instance

The nuclear option, and the simplest way to go in some cases. If you
need to make a major version leap (aka. migrating an ancient Gitorious
installation) you might want to consider simply snapshotting the old
one and recovering in a freshly installed new one. This also has the
benefit of not screwing up your older, working installation if
something goes wrong.

(See the backup/recovery chapter below)

* TODO Authentication & authorization
** LDAP integration
** Private projects/repositories
* TODO Keeping it running
** Monit
** Diagnostic checks
* Backup, recovery, migration, cloning

Gitorious has support for snapshotting and restoring its state, which
makes it possible to easily perform backups, disaster recovery,
cloning and migration of Gitorious sites.

** Using the snapshot/restore commands

If you're on a recent version of Gitorious (>v2.3.0) you'll find two
commands under the scripts directory: scripts/snapshot and
scripts/restore. Each of them takes a single parameter: the path of
the tar file you want your Gitorious installation backed up to, or
restored from. Note that you'll need to launch the commands from the
root directory of your Gitorious install (the directory where you find
your Rakefile, Gemfile, config directory etc).

** How to perform snapshots in older Gitorious versions

It's fairly straightforward to add these new snapshot|restore commands
to an older Gitorious instance a well: you only need to clone the
latest version of the Gitorious code, and copy the following files to
the same locations in your current, older installation:

=script/restore=
=script/snapshot=
=lib/tasks/backup.rake=

** Assumptions and caveats

- For disaster recovery, you'll first need to get a functional
  installation of Gitorious up and running, after which you can run
  the restore command to bring in your data again. Note that the
  snapshot tarball also includes the configuration files from your old
  Gitorious installation. They are not automatically copied into your
  new installation, but can be used to recreate your old config in
  your new Gitorious installation (useful if your previous Gitorious
  installation had custom LDAP integration, custom hooks etc).

- Snapshots will not preserve any custom code or theming you may have
  added to your Gitorious installation: any such local modifications
  will need to be backed up and restored separately

- Some operations in Gitorious are asynchronous, meaning they are
  performed by publishing/consuming messages on a queue. The
  snapshot/restore commands don't currently capture or restore the
  state of the queue, so any current work on the queue will be lost.

- The snapshot/recovery commands assume that you have the time and
  disk-space to slurp down all your hosted repos into a local
  tarball. Sites with huge amounts of git repository data may
  therefore need more custom backup schemes.

- The restore command assumes that no breaking changes have happened
  between the version you snapshot from, and the version you restore
  your data into. In the future, major Gitorious version jumps may
  necessitate a more manual restore procedure due to changes in
  configurations, db schema, folder structure etc.

** Scenarios

The snapshot|restore commands are useful for multiple tasks beyond
just standard backups.

*** Backup and disaster recovery

Run periodic backups, for instance via cron. Execute the snapshot
command, for example like this script/snapshot
/tmp/todays-snapshot.tar. Transfer the newly created tarball to
another server, offsite location or something like Amazon S3.

If disaster strikes on your Gitorious installation, install a new
instance of Gitorious, then run script/restore todays-snapshot.tar to
restore your old state in the new installation.

*** Migrations and clones

The same procedure is useful if you just need to move or clone your
Gitorious state from one server to another. Snapshot the old one, copy
the tarball file over to the other installation and restore
there. Simple.

*** Upgrading

Different scenario, same procedure: if you need to upgrade from an
older version of Gitorious and don't want to bother with carefully
upgrading your Gitorious instance across multiple versions, you can
simply snapshot the state of your old Gitorious site, install a fresh
new Gitorious instance and just restore your state there.

*** Snapshots and rollbacks for development and testing

If you're a developer extending, customizing or developing new
features for Gitorious, you can use the snapshot|restore commands to
simply setting up and restoring multiple standard database/repository
states in order to simplify testing.

* TODO Scaling
** Caching with Vagrant
** Horizontal scaling
   what sort of hardware will you need to keep a single server running
   under misc typical usage scenarios?
** Vertical scaling
   distributing the load over multiple serves
** Repository hashing/sharding

* The setup on gitorious.org
  As you probably know, gitorious.org runs the exact same version of
  the Gitorious mainline repository as distributed on
  gitorious.org. The setup we're running on those servers may be a bit
  more complex than what you need to setup yourself, but in case
  you're curious or plan to operate a Gitorious site with hundreds of
  thousands of users, this chapter is for you.

** Deployment
   We use [[https://github.com/capistrano/capistrano/wiki][Capistrano]] to deploy to the gitorious.org servers. We keep
   our Capfile and deploy.rb in a separate Git repository, and deploy
   from that repository.

   The configuration files for the gitorious.org servers
   (database.yml, gitorious.yml etc) are kept in this repository and
   pushed (via Capistrano's =upload= task) to the =app/shared=
   directory on the server after the code is updated; which in turn
   are symlinked into =app/current/config=. The rest of the deployment
   process is fairly standard; but we have added Capistrano tasks for
   starting/stopping/re-indexing Thinking Sphinx, starting/stopping
   Resque workers etc.

   The =restart= task we use is a bit special. Since we use Unicorn
   (more on that later), we don't do the =touch tmp/restart.txt=
   maneuvre, and we want to reindex the search index after
   deploying. In our previous setup we ran the indexing from
   Capistrano, which caused some really long-running deployments with
   a lot of output. Our current =restart= task emits an Upstart event
   which triggers a =post-deploy= Upstart task to run on the
   server. The last action performed is to send a USR2 to the Unicorn
   master, which results in reloading the server. When the
   =post-deploy= process has ended on the server, a deployment report
   is sent by email to us with a result of what happened (still work
   is still not 100% done).

** Web servers
   Our web/app server setup looks like this:

*** Varnish
    We run [[https://www.varnish-cache.org/][Varnish]] for caching on gitorious.org. Varnish is basically
    a zero-config setup, and will do wonderful things to the
    responsiveness of your app provided you take care of two things:

    - Any request with a Set-Cookie response header will not be cached
      by Varnish
    - As long as the Cache-Control response header is set to public,
      Varnish will cache the request for as long as specified by the
      max-age parameter.

    Varnish is set up to handle port 80 (HTTP) on our servers, and is
    set up with a single backend: the private Nginx server mentioned
    below. This means that Varnish will cache as much as it can of any
    requests on port 80 of gitorious.org.

*** Nginx
    We run [[http://nginx.org/][Nginx]] on port 443, since Varnish doesn't run SSL. The
    server running on gitorious.org:443 will serve any static files
    directly from =Rails.root= on the server, and proxy any other
    request to the public Varnish server on port 80.

    Nginx is also set up to listen on a private port, where it
    receives requests from (only) Varnish. Like the HTTPS Nginx
    server, this will deliver any static assets directly, and pass all
    other requests over a UNIX socket to Unicorn.

    Nginx is also set up to deliver sending of other files,
    intercepting the =X-Accel-Redirect= response headers emitted by
    Gitorious; equivalent of Apache mod_x_sendfile's =X-Sendfile=
    headers. To enable this, we have =frontend_server:nginx= in the
    =gitorious.yml= file on gitorious.org, and the configuration in
    Nginx looks like this:

#+BEGIN_SRC conf
  # Will deliver /srv/gitorious/tarballs-cache/filename.tar.gz
  location /tarballs/ {
    internal;
    alias /srv/gitorious/tarballs-cache/;
  }

  location /git-http/ {
    internal;
    alias /srv/gitorious/repositories/;
  }
#+END_SRC

    If a user requests
    https://gitorious.org/gitorious/mainline/archive-tarball/master
    Gitorious will (once the tarball has been generated) respond with
    an =X-Accel-Redirect= header like
    =/tarballs/gitorious-mainline-$sha1.tar.gz= (=$sha1= is which SHA1
    the master branch points to at request time), which is picked up
    by Nginx by the first rule above. Nginx will resolve this to the
    file =/srv/gitorious/tarballs-cache/$sha1.tar.gz= and deliver this
    file directly.

    The =/tarballs/= locations are marked as private in Nginx, which
    means a user isn't allowed to request them directly. Using Apache
    with mod_x_sendfile the =X-Sendfile= header would contain the full
    path to the repository, while Nginx lets us maintain a symbolic
    mapping resolved by Nginx itself.

    The same mechanism is used for Git over HTTP.

*** Unicorn
    [[http://unicorn.bogomips.org/][Unicorn]] is a Ruby based HTTP server leaning heavily on fundamental
    UNIX concepts. Unicorn works by starting a master process which
    loads the full Rails environment. Once this is done, it will run
    fork(2) to create 16 child processes (this is how many workers we
    have running on gitorious.org). These child processes will inherit
    the socket set up by the master process, which means the kernel
    will take care of load balancing the requests to the active worker
    processes.

    Unicorn is designed for chaotic situations, like the one we have
    on gitorious.org. An IO intensive application like Gitorious will
    run into problematic situations caused by things like IO load all
    the time, and our previous setup (Apache and Passenger) would end
    up with some really CPU and memory hungry processes running for a
    long time. Our Unicorn setup has a strict timeout of 30 seconds
    for any request, which means that any request that takes more than
    30 seconds to complete will cause the worker process to be
    killed. And once the worker is killed, the master will immediately
    fork again, with the new child process ready to serve requests
    right away.

    Like the good UNIX citizen Unicorn is, the easiest way to
    communicate with it is using signals. We use the following signals
    on gitorious.org:
    - We send a USR2 to the master process after deploying a new
      version of Gitorious. This causes the master process to spawn a
      new master process; using the newly deployed code. Once the new
      master is started, it looks for a PID file for the "old" master
      process in =pid_dir/unicorn.pid.oldbin=. If this file exists, it
      sends a QUIT signal to that, which causes it do shut down itself
      and all its worker processes. This gives us a zero downtime
      deployment, which is a big deal for us.
    - We send a USR1 to the master process after rotating the logs
      (done by =logrotate=). This causes the master and worker
      processes to reopen the log files.

    The Unicorn configuration file we use on gitorious.org is
    practically identical to the one [[https://gitorious.org/gitorious/mainline/blobs/master/config/unicorn.sample.rb][in Gitorious mainline]], except we
    use a full path in =RAILS_ROOT= since expanding a relative path
    would resolve to Capistrano's =app/releases= directory.

** Message queue and consumers
   gitorious.org has been using [[http://activemq.apache.org/][Apache ActiveMQ]] since 2009, and we
   have not had a single problem with using that. No messages dropped,
   no crashes, no problems at all. The [[http://code.google.com/p/activemessaging/wiki/ActiveMessaging][ActiveMessaging]] Rails plugin
   we've been running with, however, has never worked really
   well. Some considerable memory leaks forced us to use [[http://mmonit.com/monit/][Monit]] to kill
   =script/poller= processes consuming more than a few hundred
   megabytes of RAM, and killing these processes has often led to
   zombie processes on the server; potentially even zombies still
   connected to ActiveMQ.

   When setting up the new servers for gitorious.org we chose to go
   with [[https://github.com/defunkt/resque][Resque]] instead, which has been supported in Gitorious for a
   year or so. Resque uses the [[http://redis.io/][Redis key-value store]] as its
   queue. Resque works similarly to Unicorn by setting up a master
   worker polling for new messages from Redis and forking a child
   process to process each message. Once the child is done processing
   it exits, which means we don't leak memory.

   Switching to Redis/Resque is done in a few simple steps:

*** Install Redis
    On Ubuntu/Debian servers:
#+BEGIN_EXAMPLE
sudo apt-get install redis-server
update-rc.d redis-server defaults
sudo service start redis-server
#+END_EXAMPLE

    On RHEL/CentOS-like systems:
#+BEGIN_EXAMPLE
sudo yum install redis
sudo chkconfig redis on
sudo /etc/init.d/redis start
#+END_EXAMPLE

*** Configure Gitorious to use Resque
    This is a simple setting in gitorious.yml:
#+BEGIN_SRC yaml
messaging_adapter: resque
#+END_SRC

*** Restart the app server
    This depends on which server you're running. If you're using Passenger:
#+BEGIN_EXAMPLE
touch tmp/restart.txt
#+END_EXAMPLE

    If you're using Unicorn

#+BEGIN_EXAMPLE
kill -USR2 /path/to/unicorn.pid
#+END_EXAMPLE

*** Start a worker
    The =bin/rake= script shipping with Gitorious will run a rake task
    from anywhere, setting up the correct =RAILS_ENV=, =HOME=
    environment variables and ensuring the task is run as the user
    specified as =gitorious_user= in =gitorious.yml=, and Resque
    workers are run with Rake:

#+BEGIN_EXAMPLE
QUEUE=* /path/to/gitorious/bin/rake resque:work
#+END_EXAMPLE

    To run dedicated workers for single queues, change the =QUEUE=
    environment variable, eg.

#+BEGIN_EXAMPLE
QUEUE="/queue/GitoriousPush" /path/to/gitorious/bin/rake resque:work
#+END_EXAMPLE

    Since the =bin/rake= task can be called directly, we simply added
    an Upstart script with an =exec= stanza (no shell required) to
    control the Resque workers:

#+BEGIN_SRC conf
description "Run a Resque worker on all queues"
author "Marius Mårnes Mathiesen <marius@gitorious.com>"

start on started gitorious/unicorn
stop on runlevel [06]

env QUEUE=*
env PIDFILE=/path/to/gitorious/pids/resque-worker1.pid
exec /path/to/gitorious/bin/rake resque:work

#+END_SRC

** Init scripts and process babysitting
   We're still a little on the fence with regards to
   babysitting/monitoring processes. Our experience with
   ActiveMessaging has made us set up Monit, but we're not using it
   yet. We start all the services using some really simple Upstart
   scripts. This was the main motivation for shipping the =bin/=
   scripts with Gitorious, since these set up everything themselves we
   don't need to spawn a shell to start them (eg. to set up
   environment variables, dropping privileges etc.). Spawning a shell
   would confuse Upstart, which relies on counting fork calls and
   keeping track of PID files.

   In particular, the way Unicorn is used for hot deployment would
   lead Upstart to try to track the PID of the old master once a new
   master was started. Instructing Upstart to =respawn= Unicorn would
   get us into trouble when using the =USR2= technique to reload
   Unicorn.

   Monit keeps track of PID files, which would work better with
   Unicorn.

** Git proxying
   We run a stack of native git daemon processes listening on port
   9400 on the servers, and have set up Gitorious' git-proxy script to
   proxy requests to these (this proxy will translate the incoming
   paths to the paths on the file system before passing them on to the
   native git daemons). The git-proxy process listens on 127.0.0.1:9418.

   We've set up [[http://haproxy.1wt.eu/][HAProxy]] in front of the git-proxy process, listening
   on the public interfaces (gitorious.org:9418, ssh.gitorious.org:443
   and 2a02:c0:1014::1:9418). Running haproxy in front of these may
   not be strictly necessary, but we found it easier to set up the
   public facing addresses/ports to listen to in the HAProxy
   configuration; and we're a little more comfortable running HAProxy
   to the public as it gives us fine-grained control over
   server/client timeouts.

   Again, we used Upstart to start the git:// protocol handlers, since
   Upstart lets us specify the dependency between them. Our
   git-daemons Upstart recipe is set up like this:

#+BEGIN_SRC conf
start on started gitorious/unicorn
#+END_SRC

   which means it's started once the Unicorn process is running. The
   Upstart recipe for our git-proxy, which requires the git-daemons to
   be running, is like this.

#+BEGIN_SRC conf
start on started gitorious/git-daemons
stop on stopped gitorious/git-daemons
#+END_SRC

   This way the native git daemons will be started as soon as the web
   app is ready, and the git proxy will be started once the git
   daemons are ready.

* Troubleshooting

You're running your own Gitorious site. Now something seems to be
broken. Where do you start?

** Diagnostics CLI tool

Gitorious includes a self-diagnostic tool (available in v2.3.0 and
onwards).

Execute scripts/diagnose (as superuser/root), and Gitorious will print
out a summary of its internals. Obvious problems in your setup will
show up here, which should give you a clue as to what could be amiss
in your installation.

** Diagnostics dashboard url

You can also check the health of the site via the web frontend. If you
are a site admin, browse to /admin/diagnostics at your Gitorious
site. You'll be greeted with a diagnostics summary very similar to the
script/diagnose command.

** Check the FAQ

(See FAQ chapter below)

** Ask the community

If you're still stuck, consider asking the Gitorious community for
suggestions.

The core contributors and quite a few community members subscribe to
the [[http://groups.google.com/group/gitorious?hl=en][Gitorious Google Group]]. There's also an IRC channel
available: #gitorious at freenode.net

Finally, if you are considering paid support/help, note that [[http://gitorious.com][Gitorious
AS]] offers commercial support.

* TODO Frequently Asked Questions
* Contributing to Gitorious
** Bug reports

Found a bug or annoyance? Please let the maintainers know via the official
issuetracker at [[https://issues.gitorious.org/][https://issues.gitorious.org/]].

** Hacking on Gitorious
*** TODO Setting up your development environment

Howto: Set up enough dependencies and code locally to run the Gitorious test suite.

*** TODO Deploying and testing your code in a "cleanroom" VM

Howto: Deploy and test your code in a basic gitorious community edition VM

*** Coding styleguide

As Gitorious is a codebase of decent size (by Ruby standards at
least), we try to adhere to a few guidelines to keep the codebase
clean.

The number one takeaway is that there's some level of flexibility in
the "rules" outlined below, but the most important thing is that your
code _should look good_ and be easily _readable_ and _understandable_
for everyone else. The Gitorious codebase has its dark corners,
possibly filled with dragons, but we try to improve things as we see
them. "Leave the source in a better state than you found it" is solid
advice.

Pay attention to what you commit; always review pending changes with
`git diff --staged` and look for things that violates the outlines
below (git is being helpful and highlights some things, such as
trailing whitespace).

In general, try to follow the style of the existing code, and pay
attention to how the code you're writing _actually looks_, not just
how it works.

**** General Guidelines

- Lines should stay below 80 chars or so.
- No tabs.
- Don't get too clever.
- No trailing whitespace

**** Ruby

Generally the points in Christian Neukirchens
[[RUBY-STYLE][http://github.com/chneukirchen/styleguide/raw/master/RUBY-STYLE]] apply.

**** Javascript

- 4 spaces, no tabs
- 80 chars or less line length
- Local variables must use the `var` keyword
- Use (one) blank line to group statements together where suited
- Always use a single space after a keyword, and before a curly brace.
- Curly braces goes on the same line

#+begin_src javascript
    // Wrong
    function foo (arg){
    // Wrong
    function foo(arg)
    {
    // Correct
    function foo(arg) {
#+end_src


The same applies for conditionals:

#+begin_src javascript
    // Wrong
    if (arg){
    // Wrong
    if(arg)
    {
    // Correct
    if foo(arg) {
        ...
    } else {
        ...
    }
#+end_src

One possible exception to the above is if the conditionals argument is
wrapped on multiple lines, the brace can be placed on a new line to
ease readability of the conditional body:

#+begin_src javascript
     if ((foo && barIsJustAWordUsedforDemonstrations) ||
         kittensAreFluffy && doesNotSayWoof)
     {
         ...
     }
#+end_src

However, long boolean expressions should be avoided in the first place.

**** CSS

- four space indent
- no tabs
- multiple selectors on seperate lines, unless singleworded

#+begin_src css
     /* wrong */
    \#foo #bar div.foo, #baz p#quux span.foo {
        ...
    }
    /* Correct */
    \#foo #bar div.foo,
    \#baz p#quux span.foo {
        ...
    }
#+end_src


- Opening brace on the same line as the selector

**** HTML

- 2 spaces indendation
- No tabs
- Prefer to indent deep nesting on a newline+indent, so the structure is easier to follow

*** Branching model

Gitorious uses
[the git-flow branching model](http://nvie.com/posts/a-successful-git-branching-model/)
for branching. This means that the master branch is stable, and is
only merged to once a feature has been completed.

New features are created in feature branches (named `feature/$name`)
and then merged into the `next` branch once finished. Such features
arrive in `master` as new releases.

When contributing new features into Gitorious as merge requests, these
should be started the `next` branch, and marked as such when proposed.

The exception to this is hotfixes, which may be started from and
proposed merged into `master`. Please note that hotfixes should not
implement new functionality.

** Don't have time yourself? Fund new features!

If your company has urgent need of new features/modifications in
Gitorious, please get in touch with the core contributors via
team@gitorious.org for funding development of your proposed features.

* TODO Need more help?
** Google Group
** #gitorious on IRC
** Gitorious AS services & products

* TODO Feedback
